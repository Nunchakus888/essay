---
layout: post
title:  就😄最近观发生在中国大地的AV大战之后感 ---拿着笔记本的吃瓜群众～～
date:   2017-08-04 01:08:08 +0800
categories: diary
location: ShangHai, China
description: 中国大地的各大开发者社区统统被Angular&Vue的撕逼大战刷屏-几近波及世界😄-那些大佬真是着急了什么话都能说得出来啊-干货满满的-我默默点赞-默默吃瓜-默默做笔记િ🙄ી&致敬大佬们！
tail: 我是小尾巴～～
cover: "封面？"
---
---

中国大地的各大开发者社区统统被Angular&Vue的撕逼大战刷屏-几近波及世界😄-那些大佬真是着急了什么话都能说得出来啊-干货满满的-我默默点赞-默默吃瓜-默默做笔记િ🙄ી&致敬大佬们
====================================

### AngularJs双向数据绑定
    AngularJS 1.x会为每一个进行数据绑定的HTML标签创建一个watcher。然后，当发生任何可能会导致数据模型被修改的情况下，就会启动一轮$digest循环，把所有watcher全部运行一遍，看看有没有东西需要自己更新（目前Vue的实现思想与此类似，它底层使用了Object.defineProperty）。AngularJS 1.x在这个地方还有一个实现细节也非常糟糕，它为了保证数据模型的改动不会丢失，可能会重复运行多次$digest循环，而且搞了一个TTL机制，如果$digest循环检查了10次，发现模型还没有稳定下来，直接抛异常。
    -脏值检测的效率问题：在AngularJS 1.x里面，这个问题没有得到很好的解决。它每次都会生成一份对象副本，当发生修改之后，会把新的对象和原来的对象进行“深比较”。当JS对象的结构非常深的时候，Tree型遍历会消耗大量的CPU时间，因为Tree型遍历一般需要递归，而在JS里面做递归运行效率非常差。同时因为每次都拷贝一个对象副本，内存占用也比较大，这就是你们在网上看到很多吐槽说AngularJS 1.x的数据绑定有效率问题的根本原因。
    
### Angular2+ 双向数据绑定
    如何才能检测到某个JS对象的值被修改了：新版本的Angular引入了Zones.js，并在此基础上做了自己的封装，Zones会拦截所有可能修改数据模型的操作。实际上在浏览器环境下，只有3个典型的异步回调才可能造成数据模型被修改：事件回调、Ajax回调、定时器回调。所以，Zones.js拦截了所有这些回调函数，自己做了代理。这样，它就可以在数据发生修改的时候精确地给Angular发出通知，因此，在Angular新版本里面，不会再出现更新丢失的问题，你再也不用自己去手动调用该死的$apply()方法了。
    - 脏值检测的效率问题：新版本的Angular引入了RxJS+Immutable的设计，非常有效地避开了这个问题。根据Victor Savkin的说法，这个全新的实现把运行效率从O(N)提升到了O(logN)。所以，在新版本的Angular里面，不再存在所谓的“绑定效率”问题了，有一些无脑黑的文章还在扯这个问题，明显是胡说。
    
### AOT&JIT
    AOT(Ahead Of Time，预编译)是和JIT(Just In Time，即时编译)相对应的一个概念，
    虽然JavaScript代码是解释执行的，
    但是浏览器在执行JS代码的时候同样需要编译，
    这种`一边编译一遍执行的方式叫做JIT`。
    JIT存在一些问题，首先是 `效率不够高，其次是没法做深度的代码优化`。
    tree-shaking的意思是“摇树”，这是一个非常生动形象的比喻，当你摇一颗树的时候，那些枯萎的叶子就会掉下来。而我们在编写应用的过程，经常会有一些代码可能根本用不到，
    有了tree-shaking之后，这些用不到的东西就可以自动被摇掉，
    从而可以保证最终打包出来的应用体积足够小。
    如果没有静态类型的TypeScript，要实现tree-shaking也会非常麻烦。

### To be continued..
